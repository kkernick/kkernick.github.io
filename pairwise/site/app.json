[{"name": "app.py", "content": "#\n# Heatmapper\n# Pairwise\n#\n# This file contains the ShinyLive application for Pairwise Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n# Last Modified: 2024/02/03\n#\n\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nfrom matplotlib.pyplot import subplots, colorbar\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\nfrom scipy.spatial.distance import pdist, squareform\nfrom Bio.PDB import PDBParser\nfrom io import BytesIO\nfrom sys import modules\nfrom pathlib import Path\nfrom pandas import DataFrame, read_csv, read_excel, read_table\n\n\n# Interoperability between ShinyLive and PyShiny\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tSource = \"https://raw.githubusercontent.com/kkernick/kkernick.github.io/main/pairwise/example_input/\"\n\tasync def download(url): r = await pyfetch(url); return await r.bytes() if r.ok else None\nelse:\n\tfrom os.path import exists\n\tSource = \"../example_input/\"\n\tasync def download(url): return open(url, \"rb\").read() if exists(url) else None\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n\t# Cache for examples. We can't assume users will have unique file names, so we cannot use the cache for\n\t# Uploaded files. Regardless, this prevents the application from fetching the example every time its needed.\n\tCache = {}\n\n\t# Information about the Examples\n\tInfo = {\n\t\t\"example1.txt\": \"This example dataset represents pairwise distances between C-alpha atoms in ubiquitin (1ubq).\",\n\t\t\"example2.txt\": \"This example dataset was generated randomly.\",\n\t\t\"example3.txt\": \"This example dataset was generated randomly.\"\n\t}\n\n\n\tasync def LoadData():\n\t\t\"\"\"\n\t\t@brief Returns a table containing the pairwise matrix.\n\t\t@returns\tA DataFrame containing the data requested, formatted as a pairwise matrix, or\n\t\t\t\t\t\t\tan empty DataFrame if we're on Upload, but the user has not supplied a file.\n\t\t\"\"\"\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None:\n\t\t\t\t\treturn DataFrame()\n\t\t\tn = file[0][\"name\"]\n\t\t\tf = file[0][\"datapath\"]\n\t\telse:\n\t\t\tn = input.Example()\n\t\t\tf = Cache[n] if n in Cache else BytesIO(await download(Source + input.Example()))\n\n\t\tmatch Path(n).suffix:\n\t\t\tcase \".csv\": return ChartMatrix(read_csv(f))\n\t\t\tcase \".xlsx\": return ChartMatrix(read_excel(f))\n\t\t\tcase \".pdb\": return PDBMatrix(f)\n\t\t\tcase _: return ChartMatrix(read_table(f))\n\n\n\tdef PDBMatrix(file):\n\t\t\"\"\"\n\t\t@brief Generates a pairwise matrix from a PDB file\n\t\t@param file: The path to a PDB file (Or BytesIO file if applicable)\n\t\t@returns The pairwise matrix.\n\t\t\"\"\"\n\n\t\tparser = PDBParser()\n\t\tstructure = parser.get_structure('protein', file)\n\n\t\t# Extract atomic coordinates\n\t\tcoordinates = []\n\t\tfor model in structure:\n\t\t\tfor chain in model:\n\t\t\t\t\tif chain.id == input.Chain():\n\t\t\t\t\t\t\tfor residue in chain:\n\t\t\t\t\t\t\t\t\tfor atom in residue:\n\t\t\t\t\t\t\t\t\t\t\tcoordinates.append(atom.coord)\n\n\t\t# Calculate pairwise distances\n\t\tdistances = pdist(coordinates, metric=input.DistanceMethod().lower())\n\t\tdistance_matrix = squareform(distances)\n\n\t\treturn DataFrame(distance_matrix)\n\n\n\tdef ChartMatrix(df):\n\t\t\"\"\"\n\t\t@brief Generates a pairwise matrix from charts\n\t\t@param df:\tThe DataFrame containing the data. This can either be a chart\n\t\t\t\t\t\t\t\tcontaining {x,y,z} columns outlining each point on a row, with\n\t\t\t\t\t\t\t\tan optional name column (Any fourth column), a chart to which\n\t\t\t\t\t\t\t\tan explicit \"Name\" column is provided, to which the first row\n\t\t\t\t\t\t\t\tand column are assumed variable names for an existing matrix,\n\t\t\t\t\t\t\t\tor the default, where it is assumed that the chart is an\n\t\t\t\t\t\t\t\tunlabeled collection either of points, or an existing matrix.\n\t\t@returns A DataFrame containing the provided data as a pairwise matrix\n\t\t\"\"\"\n\n\t\t# If \"Name\" is found, its assumed to be the label for the points.\n\t\tif \"Name\" in df:\n\t\t\tpoint_names = df[\"Name\"]\n\n\t\t# If explicit coordinates ar eprovided, use them, with the final column used as labels.\n\t\tif 'x' in df.columns and 'y' in df.columns and 'z' in df.columns:\n\t\t\tcoordinates = df[['x', 'y', 'z']].values\n\t\t\tpoint_names = df[list(set(df.columns) - set(['x', 'y', 'z']))[0]].values\n\n\t\t# Magic. How this handles all other cases I don't know, but it somehow works.\n\t\telse:\n\t\t\tcoordinates = df.iloc[:, 1:].values\n\t\t\tpoint_names = None\n\n\t\t# Calculate a distant matrix, and return it\n\t\tdistances = pdist(coordinates, metric=input.DistanceMethod().lower())\n\t\tdistance_matrix = squareform(distances)\n\t\treturn DataFrame(distance_matrix, index=point_names, columns=point_names)\n\n\n\tasync def GenerateHeatmap():\n\t\t\"\"\"\n\t\t@brief Generates the Heatmap\n\t\t@returns The heatmap\n\t\t\"\"\"\n\n\t\tdf = await LoadData()\n\t\tfig, ax = subplots()\n\n\t\tim = ax.imshow(df, cmap=input.ColorMap().lower(), interpolation=input.Interpolation().lower())\n\t\tcolorbar(im, label=\"Distance\")\n\n\t\treturn ax\n\n\n\t@output\n\t@render.table\n\tasync def LoadedTable(): return await LoadData()\n\n\n\t@output\n\t@render.plot\n\tasync def Heatmap(): return await GenerateHeatmap()\n\n\t@output\n\t@render.text\n\tdef ExampleInfo():\n\t\treturn Info[input.Example()]\n\n\n\t@session.download(filename=\"table.csv\")\n\tasync def DownloadTable(): yield await LoadData().to_string()\n\n\n\t@session.download(filename=\"heatmap.png\")\n\tasync def DownloadHeatmap():\n\t\tax = await GenerateHeatmap()\n\n\t\toutput = BytesIO()\n\t\tFigureCanvasAgg(ax.figure).print_png(output)\n\n\t\toutput.seek(0)\n\t\tyield output.read()\n\n\napp_ui = ui.page_fluid(\n\n\t# Welcome back, NavBar :)\n\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\tui.navset_bar(\n\t\tui.nav_panel(ui.HTML(\"<a href=https://kkernick.github.io/expression/site/index.html>Expression</a>\"), value=\"Expression\"),\n\t\tui.nav_panel(ui.HTML(\"<a href=https://kkernick.github.io/pairwise/site/index.html>Pairwise</a>\"), value=\"Pairwise\"),\n\t\tui.nav_panel(ui.HTML(\"<a href=https://kkernick.github.io/image/site/index.html>Image</a>\"), value=\"Image\"),\n\t\tui.nav_panel(ui.HTML(\"<a href=https://kkernick.github.io/geomap/site/index.html>Geomap</a>\"), value=\"Geomap\"),\n\t\tui.nav_panel(ui.HTML(\"<a href=https://kkernick.github.io/geocoordinate/site/index.html>Geocoordinate</a>\"), value=\"Geocoordinate\"),\n\t\tui.nav_panel(ui.HTML(\"<a href=https://kkernick.github.io/about/site/index.html>Pairwise</a>\"), value=\"About\"),\n\t\ttitle=\"Heatmapper\",\n\t\tselected=\"Pairwise\",\n\t),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\t# If the user needs help with the formatting.\n\t\t\tui.HTML(\"<a href=https://kkernick.github.io/about/site/index.html>Data Format</a>\"),\n\n\t\t\t# Specify whether to use example files, or upload one.\n\t\t\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=\"Example\", inline=True),\n\n\t\t\t# Only display an input dialog if the user is one Upload\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.SourceFile === 'Upload'\",\n\t\t\t\tui.input_file(\"File\", \"Choose a File\", accept=[\".csv\", \".txt\", \"xlsx\", \".pdb\", \".dat\"], multiple=False),\n\t\t\t),\n\n\t\t\t# Otherwise, add the example selection and an info button.\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.SourceFile === 'Example'\",\n\t\t\t\t\"Choose an Example File\",\n\t\t\t\tui.layout_columns(\n\t\t\t\t\tui.input_select(id=\"Example\", label=None, choices={\n\t\t\t\t\t\t\t\t\t\t\t\"example1.txt\": \"Example 1\",\n\t\t\t\t\t\t\t\t\t\t\t\"example2.txt\": \"Example 2\",\n\t\t\t\t\t\t\t\t\t\t\t\"example3.txt\": \"Example 3\",\n\t\t\t\t\t}),\n\t\t\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\t\t\tcol_widths=[10,2],\n\t\t\t\t)\n\t\t\t),\n\n\t\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html\n\t\t\tui.input_select(id=\"DistanceMethod\", label=\"Distance Method\", choices=[\n\t\t\t\t\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Mahalanobis\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"], selected=\"Euclidean\"),\n\n\t\t\t# https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html\n\t\t\tui.input_select(id=\"Interpolation\", label=\"Interpolation\", choices=[\n\t\t\t\t\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"], selected=\"Nearest\"),\n\n\t\t\t# Set the ColorMap used.\n\t\t\tui.input_select(id=\"ColorMap\", label=\"Color Map\", choices=[\"Viridis\", \"Plasma\", \"Inferno\", \"Magma\", \"Cividis\"], selected=\"Viridis\"),\n\n\t\t\t# Specify the PDB Chain\n\t\t\tui.input_text(\"Chain\", \"PDB Chain\", \"A\"),\n\n\t\t\t# Add the download buttons.\n\t\t\tui.layout_columns(\n\t\t\t\tui.download_button(\"DownloadTable\", \"Download Table\"),\n\t\t\t\tui.download_button(\"DownloadHeatmap\", \"Download Heatmap\")\n\t\t\t),\n\n\t\t\tid=\"SidebarPanel\",\n\t\t\twidth=350,\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tui.navset_tab(\n\t\t\t\tui.nav_panel(\"Interactive\", ui.output_plot(\"Heatmap\", height=\"90vh\")),\n\t\t\t\tui.nav_panel(\"Table\", ui.output_table(\"LoadedTable\"),),\n\t\t),\n\t)\n)\n\napp = App(app_ui, server)", "type": "text"}, {"name": "requirements.txt", "content": "biopython", "type": "text"}]