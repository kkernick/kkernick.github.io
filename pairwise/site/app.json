[{"name": "app.py", "content": "#\n# Heatmapper\n# Pairwise\n#\n# This file contains the ShinyLive application for Pairwise Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n# Last Modified: 2024/02/10\n#\n\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nfrom matplotlib.pyplot import subplots, colorbar\nfrom scipy.spatial.distance import pdist, squareform\nfrom Bio.PDB import PDBParser\nfrom Bio import SeqIO\nfrom io import BytesIO\nfrom sys import modules\nfrom pathlib import Path\nfrom pandas import DataFrame, Series, read_csv, read_excel, read_table\nfrom copy import deepcopy\n\n\n# Interoperability between ShinyLive and PyShiny\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tSource = \"https://raw.githubusercontent.com/kkernick/kkernick.github.io/main/pairwise/example_input/\"\n\tasync def download(url): r = await pyfetch(url); return await r.bytes() if r.ok else None\nelse:\n\tfrom os.path import exists\n\tSource = \"../example_input/\"\n\tasync def download(url): return open(url, \"rb\").read() if exists(url) else None\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n\n\t# We use a two-tiered cache system to allow the user to modify files without requiring\n\t# re-fetching to restore the original values.\n\t#\n\t# Base is the immutable, primary cache, that contains the contents of files (example or uploaded)\n\t# in their original form. Nothing is allowed to modify the contents of values in Base, nor are they\n\t# allowed to be exposed to the user in any capacity. If Base is not populated, content will be fetched\n\t# Externally (Either by opening a user-supplied file, or fetching the content online)\n\t#\n\t# Cache is the modifiable, secondary cache, that contains the content of Base. The user is only provided\n\t# Data via Cache, as an abstraction of Base. If Cache is not populated, content will be fetched by making\n\t# A copy of the value within Base.\n\tBase = {}\n\tCache = {}\n\n\n\n\t# Information about the Examples\n\tInfo = {\n\t\t\"example1.txt\": \"This example dataset represents pairwise distances between C-alpha atoms in ubiquitin (1ubq).\",\n\t\t\"example2.txt\": \"This example dataset was generated randomly.\",\n\t\t\"example3.txt\": \"This example dataset was generated randomly.\"\n\t}\n\n\n\tdef HandleData(n, i):\n\t\t\"\"\"\n\t\t@brief Given the file name n, handle the file at i\n\t\t@param n The name of the file, extension is used to differentiate\n\t\t@param i The path to the file.\n\t\t\"\"\"\n\t\tmatch Path(n).suffix:\n\t\t\tcase \".csv\": return read_csv(i)\n\t\t\tcase \".xlsx\": return read_excel(i)\n\t\t\tcase \".pdb\": return PDBMatrix(i)\n\t\t\tcase \".fasta\": return FASTAMatrix(i)\n\t\t\tcase _: return read_table(i)\n\n\n\tasync def RawData():\n\t\t\"\"\"\n\t\t@brief Returns the raw data that has been supplied, before modifying it into a matrix.\n\t\t@returns the name associated with the values stored in the Cache.\n\t\t\"\"\"\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None: return None\n\t\t\tn = file[0][\"name\"]\n\n\t\t\t# Populate the base cache, if we need to\n\t\t\tif n not in Base: Base[n] = HandleData(n, read(file[0][\"datapath\"], \"wb\"))\n\n\t\telse:\n\t\t\tn = input.Example()\n\n\t\t\t# Populate the base cache, if we need to\n\t\t\tif n not in Base: Base[n] = HandleData(n, BytesIO(await download(Source + input.Example())))\n\n\t\t# Populate the secondary cache if we need to, and return the name for lookup.\n\t\tif n not in Cache: Cache[n] = deepcopy(Base[n])\n\t\treturn n\n\n\n\tasync def LoadData():\n\t\t\"\"\"\n\t\t@brief Returns a table containing the pairwise matrix.\n\t\t@returns\tA DataFrame containing the data requested, formatted as a pairwise matrix, or\n\t\t\t\t\t\t\tan empty DataFrame if we're on Upload, but the user has not supplied a file.\n\t\t\"\"\"\n\n\t\tn = await RawData()\n\t\tdf = DataFrame() if n is None else Cache[n]\n\t\tif n is None: return DataFrame()\n\n\t\tmatch Path(n).suffix:\n\t\t\tcase \".csv\": df = ChartMatrix(df)\n\t\t\tcase \".xlsx\": df = ChartMatrix(df)\n\t\t\tcase \".pdb\": pass\n\t\t\tcase \".fasta\": pass\n\t\t\tcase _: df = ChartMatrix(df)\n\n\t\t# Fix garbage data and return the resultant DataFrame.\n\t\treturn df.fillna(0)\n\n\n\tdef FASTAMatrix(file):\n\t\t\"\"\"\n\t\t@brief Computes the pairwise matrix from a FASTA file.\n\t\t@param file: The path to the FASTA File\n\t\t@returns a pairwise matrix.\n\t\t\"\"\"\n\n\t\t# Get information from the file\n\t\trecords = list(SeqIO.parse(open(file), \"fasta\"))\n\t\tsequences = [str(record.seq) for record in records]\n\t\tcolumn_names = [record.id for record in records]\n\n\t\t# Get our K-Mer value\n\t\tk = input.K()\n\n\t\t# Generate the value\n\t\tdictionary = {}\n\t\tfor x, seq in enumerate(sequences):\n\t\t\tkmers = [seq[i:i+k] for i in range(len(seq) - k + 1)]\n\t\t\tincrement = 1 / len(kmers)\n\t\t\tfor kmer in kmers:\n\t\t\t\t\tif kmer not in dictionary:\n\t\t\t\t\t\t\tdictionary[kmer] = [0.0] * len(sequences)\n\t\t\t\t\tdictionary[kmer][x] += increment\n\t\tfrequencies = DataFrame.from_dict(dictionary, orient='index')\n\n\t\t# Calculate matrix\n\t\tif input.MatrixType() == \"Distance\":\n\t\t\tdistances = pdist(frequencies.T, metric=input.DistanceMethod().lower())\n\t\t\treturn DataFrame(squareform(distances), index=column_names, columns=column_names)\n\t\telse:\n\t\t\treturn frequencies.corr(method=input.CorrelationMethod().lower())\n\n\n\tdef PDBMatrix(file):\n\t\t\"\"\"\n\t\t@brief Generates a pairwise matrix from a PDB file\n\t\t@param file: The path to a PDB file (Or BytesIO file if applicable)\n\t\t@returns The pairwise matrix.\n\t\t\"\"\"\n\n\t\tparser = PDBParser()\n\t\tstructure = parser.get_structure(\"protein\", file)\n\n\t\t# Extract atomic coordinates\n\t\tcoordinates = []\n\t\tfor model in structure:\n\t\t\tfor chain in model:\n\t\t\t\t\tif chain.id == input.Chain():\n\t\t\t\t\t\t\tfor residue in chain:\n\t\t\t\t\t\t\t\t\tfor atom in residue:\n\t\t\t\t\t\t\t\t\t\t\tcoordinates.append(atom.coord)\n\n\t\t# Calculate matrix\n\t\tif input.MatrixType() == \"Distance\":\n\t\t\tdistances = pdist(coordinates, metric=input.DistanceMethod().lower())\n\t\t\treturn DataFrame(squareform(distances))\n\t\telse:\n\t\t\treturn DataFrame(coordinates).corr(method=input.CorrelationMethod().lower())\n\n\n\tdef ChartMatrix(df):\n\t\t\"\"\"\n\t\t@brief Generates a pairwise matrix from charts\n\t\t@param df:\tThe DataFrame containing the data. This can either be a chart\n\t\t\t\t\t\t\t\tcontaining {x,y,z} columns outlining each point on a row, with\n\t\t\t\t\t\t\t\tan optional name column (Any fourth column), a chart to which\n\t\t\t\t\t\t\t\tan explicit \"Name\" column is provided, to which the first row\n\t\t\t\t\t\t\t\tand column are assumed variable names for an existing matrix,\n\t\t\t\t\t\t\t\tor the default, where it is assumed that the chart is an\n\t\t\t\t\t\t\t\tunlabeled collection either of points, or an existing matrix.\n\t\t@returns A DataFrame containing the provided data as a pairwise matrix\n\t\t\"\"\"\n\n\t\t# If \"Name\" is found, its assumed to be the label for the points.\n\t\tif \"Name\" in df:\n\t\t\tpoint_names = df[\"Name\"]\n\n\t\t# If explicit coordinates ar eprovided, use them, with the final column used as labels.\n\t\tif \"x\" in df.columns and \"y\" in df.columns and \"z\" in df.columns:\n\t\t\tcoordinates = df[[\"x\", \"y\", \"z\"]].values\n\t\t\tpoint_names = df[list(set(df.columns) - set([\"x\", \"y\", \"z\"]))[0]].values\n\n\t\t# Magic. How this handles all other cases I don't know, but it somehow works.\n\t\telse:\n\t\t\tcoordinates = df.iloc[:, 1:].values\n\t\t\tpoint_names = None\n\n\t\t# Calculate a distant matrix, and return it\n\t\tif input.MatrixType() == \"Distance\":\n\t\t\tdistances = pdist(coordinates, metric=input.DistanceMethod().lower())\n\t\t\treturn DataFrame(squareform(distances), index=point_names, columns=point_names)\n\t\telse:\n\t\t\treturn DataFrame(coordinates, index=point_names, columns=point_names).corr(method=input.CorrelationMethod().lower())\n\n\n\tasync def GenerateHeatmap():\n\t\t\"\"\"\n\t\t@brief Generates the Heatmap\n\t\t@returns The heatmap\n\t\t\"\"\"\n\n\t\tdf = await LoadData()\n\t\tfig, ax = subplots()\n\n\t\tim = ax.imshow(df, cmap=input.ColorMap().lower(), interpolation=input.Interpolation().lower())\n\n\t\t# Visibility of features\n\t\tif \"legend\" in input.Features(): colorbar(im, ax=ax, label=\"Distance\")\n\n\t\tif \"y\" in input.Features():\n\t\t\tax.tick_params(axis=\"y\", labelsize=input.TextSize())\n\t\t\tax.set_yticks(range(len(df.columns)))\n\t\t\tax.set_yticklabels(df.columns)\n\t\telse:\n\t\t\tax.set_yticklabels([])\n\n\t\tif \"x\" in input.Features():\n\t\t\tax.tick_params(axis=\"x\", labelsize=input.TextSize())\n\t\t\tax.set_xticks(range(len(df.columns)))\n\t\t\tax.set_xticklabels(df.columns, rotation=90)\n\t\telse:\n\t\t\tax.set_xticklabels([])\n\n\t\t# Annotate each cell with its value\n\t\tif \"label\" in input.Features():\n\t\t\tfor i in range(df.shape[0]):\n\t\t\t\t\tfor j in range(df.shape[1]):\n\t\t\t\t\t\t\tax.text(j, i, '{:.2f}'.format(df.iloc[i, j]), ha='center', va='center', color='white')\n\n\t\treturn ax\n\n\n\t@output\n\t@render.data_frame\n\t@reactive.event(input.Update, input.Reset, ignore_none=False, ignore_init=False)\n\tasync def LoadedTable(): n = await RawData(); return DataFrame() if n is None else Cache[n]\n\n\n\t@output\n\t@render.plot\n\t@reactive.event(input.Update, input.Reset, ignore_none=False, ignore_init=False)\n\tasync def Heatmap(): return await GenerateHeatmap()\n\n\t@output\n\t@render.text\n\tdef ExampleInfo(): return Info[input.Example()]\n\n\n\t@render.download(filename=\"table.csv\")\n\tasync def DownloadTable(): df = await LoadData(); yield df.to_string()\n\n\n\t@reactive.Effect\n\t@reactive.event(input.TableRow, input.TableCol)\n\tasync def UpdateValue():\n\t\t\"\"\"\n\t\t@brief Updates the value displayed in the TableVal input when the user changes Row/Column\n\t  \"\"\"\n\n\t\tn = await RawData()\n\t\tdf = DataFrame() if n is None else Cache[n]\n\n\t\trow_count, column_count = df.shape\n\t\trow, column = input.TableRow(), input.TableCol()\n\n\t\tif row < 0 or row > row_count: row = 0\n\t\tif column < 0 or column > column_count: column = 0\n\n\t\tif row < row_count and column < column_count:\n\t\t\tui.update_text(id=\"TableVal\", label=\"Value\", value=df.iloc[row, column])\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Update)\n\tasync def Update():\n\t\t\"\"\"\n\t\t@brief Updates the value in the table with the one the user typed in upon updating\n\t\t\"\"\"\n\n\t\t# Get the data\n\t\tn = await RawData()\n\t\tdf = DataFrame() if n is None else Cache[n]\n\n\t\trow_count, column_count = df.shape\n\t\trow, column = input.TableRow(), input.TableCol()\n\n\t\t# So long as row and column are sane, update.\n\t\tif row and column and row < row_count and column < column_count:\n\t\t\tmatch input.Type():\n\t\t\t\tcase \"Integer\": df.iloc[row, column] = int(input.TableVal())\n\t\t\t\tcase \"Float\": df.iloc[row, column] = float(input.TableVal())\n\t\t\t\tcase \"String\": df.iloc[row, column] = input.TableVal()\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Reset)\n\tasync def Reset(): del Cache[await RawData()]\n\n\napp_ui = ui.page_fluid(\n\n\t# Welcome back, NavBar :)\n\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\tui.navset_bar(\n\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/expression/site/index.html target=\"_blank\" rel=\"noopener noreferrer\">Expression</a>'), value=\"Expression\"),\n\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/pairwise/site/index.html target=\"_blank\" rel=\"noopener noreferrer\">Pairwise</a>'), value=\"Pairwise\"),\n\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/image/site/index.html target=\"_blank\" rel=\"noopener noreferrer\">Image</a>'), value=\"Image\"),\n\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/geomap/site/index.html target=\"_blank\" rel=\"noopener noreferrer\">Geomap</a>'), value=\"Geomap\"),\n\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/geocoordinate/site/index.html target=\"_blank\" rel=\"noopener noreferrer\">Geocoordinate</a>'), value=\"Geocoordinate\"),\n\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/about/site/index.html target=\"_blank\" rel=\"noopener noreferrer\">About</a>'), value=\"About\"),\n\t\ttitle=\"Heatmapper\",\n\t\tselected=\"Pairwise\",\n\t),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\t# If the user needs help with the formatting.\n\t\t\tui.HTML('<a href=https://kkernick.github.io/about/site/index.html target=\"_blank\" rel=\"noopener noreferrer\">Data Format</a>'),\n\n\t\t\t# Specify whether to use example files, or upload one.\n\t\t\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=\"Example\", inline=True),\n\n\t\t\t# Only display an input dialog if the user is one Upload\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.SourceFile === 'Upload'\",\n\t\t\t\tui.input_file(\"File\", \"Choose a File\", accept=[\".csv\", \".txt\", \"xlsx\", \".pdb\", \".dat\", \".fasta\"], multiple=False),\n\t\t\t),\n\n\t\t\t# Otherwise, add the example selection and an info button.\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.SourceFile === 'Example'\",\n\t\t\t\t\"Choose an Example File\",\n\t\t\t\tui.layout_columns(\n\t\t\t\t\tui.input_select(id=\"Example\", label=None, choices={\n\t\t\t\t\t\t\t\t\t\t\t\"example1.txt\": \"Example 1\",\n\t\t\t\t\t\t\t\t\t\t\t\"example2.txt\": \"Example 2\",\n\t\t\t\t\t\t\t\t\t\t\t\"example3.txt\": \"Example 3\",\n\t\t\t\t\t}),\n\t\t\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\t\t\tcol_widths=[10,2],\n\t\t\t\t)\n\t\t\t),\n\n\t\t\tui.input_action_button(\"Update\", \"Update\"),\n\t\t\tui.input_action_button(\"Reset\", \"Reset Values\"),\n\n\t\t\t# Specify Matrix Type\n\t\t\tui.input_radio_buttons(id=\"MatrixType\", label=\"Matrix Type\", choices=[\"Distance\", \"Correlation\"], selected=\"Distance\", inline=True),\n\n\t\t\t# Customize the text size of the axes.\n\t\t\tui.input_numeric(id=\"TextSize\", label=\"Text Size\", value=8, min=1, max=50, step=1),\n\n\t\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MatrixType === 'Distance'\",\n\t\t\t\tui.input_select(id=\"DistanceMethod\", label=\"Distance Method\", choices=[\n\t\t\t\t\t\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Mahalanobis\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"], selected=\"Euclidean\"),\n\t\t\t),\n\n\t\t\t# https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.corr.html\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MatrixType === 'Correlation'\",\n\t\t\t\tui.input_select(id=\"CorrelationMethod\", label=\"Correlation Method\", choices=[\"Pearson\", \"Kendall\", \"Spearman\"], selected=\"Pearson\"),\n\t\t\t),\n\n\t\t\t# https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html\n\t\t\tui.input_select(id=\"Interpolation\", label=\"Interpolation\", choices=[\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"], selected=\"Nearest\"),\n\n\t\t\t# Set the ColorMap used.\n\t\t\tui.input_select(id=\"ColorMap\", label=\"Color Map\", choices=[\"Viridis\", \"Plasma\", \"Inferno\", \"Magma\", \"Cividis\"], selected=\"Viridis\"),\n\n\t\t\t# Customize what aspects of the heatmap are visible\n\t\t\tui.input_checkbox_group(id=\"Features\", label=\"Heatmap Features\",\n\t\t\t\t\tchoices={\"x\": \"X Labels\", \"y\": \"Y Labels\", \"label\": \"Data Labels\", \"legend\": \"Legend\"},\n\t\t\t\t\tselected=[\"legend\"]),\n\n\t\t\t# Specify the PDB Chain\n\t\t\tui.input_text(\"Chain\", \"PDB Chain\", \"A\"),\n\n\t\t\t# Customize the K-mer to compute for FASTA sequences\n\t\t\tui.input_numeric(id=\"K\", label=\"K-Mer Length\", value=3, min=3, max=5, step=1),\n\n\t\t\t# Add the download buttons.\n\t\t\tui.download_button(\"DownloadTable\", \"Download Table\"),\n\n\t\t\tid=\"SidebarPanel\",\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tui.navset_tab(\n\t\t\t\tui.nav_panel(\"Interactive\", ui.output_plot(\"Heatmap\", height=\"90vh\")),\n\t\t\t\tui.nav_panel(\"Table\",\n\t\t\t\t\tui.layout_columns(\n\t\t\t\t\t\tui.input_numeric(\"TableRow\", \"Row\", 0),\n\t\t\t\t\t\tui.input_numeric(\"TableCol\", \"Column\", 0),\n\t\t\t\t\t\tui.input_text(\"TableVal\", \"Value\", 0),\n\t\t\t\t\t\tui.input_select(id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"]),\n\t\t\t\t\t\tcol_widths=[2,2,6,2],\n\t\t\t\t\t),\n\n\t\t\t\t\tui.output_data_frame(\"LoadedTable\"),\n\t\t\t\t),\n\t\t),\n\t)\n)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "requirements.txt", "content": "biopython", "type": "text"}]