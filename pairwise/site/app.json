[{"name": "app.py", "content": "from shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\n\nimport pandas as pd\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\n\n\nfrom scipy.spatial.distance import pdist, squareform\n\nfrom Bio.PDB import PDBParser\n\nfrom io import StringIO, BytesIO\n\nCached = None\nFilename = None\n\ndef server(input: Inputs, output: Outputs, session: Session):\n\n\t# Returns the data of whatever we should generate our map off of.\n\tdef LoadData():\n\t\tglobal Cached, Filename\n\n\t\t# To work well with StringIO\n\t\text = \"\"\n\n\t\t# If we have an upload file, try and open it.\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None:\n\t\t\t\t\treturn pd.DataFrame()\n\t\t\tf = file[0][\"datapath\"]\n\t\t\text = f\n\t\telse:\n\t\t\t# TODO: Actually implement the example\n\t\t\treturn pd.DataFrame()\n\n\t\tif Filename == f and Cached is not None:\n\t\t\treturn Cached\n\t\telse:\n\t\t\tFilename = f\n\n\t\t\t# Handle extensions.\n\t\t\tif ext.endswith(\".csv\"):\n\t\t\t\tCached = ChartMatrix(pd.read_csv(f))\n\t\t\telif ext.endswith(\".xlsx\"):\n\t\t\t\tCached = ChartMatrix(pd.read_xlsx(f))\n\t\t\telif ext.endswith(\".pdb\"):\n\t\t\t\tCached = PDBMatrix(f)\n\t\t\telse:\n\t\t\t\tCached = ChartMatrix(pd.read_table(f))\n\t\t\treturn Cached\n\n\n\tdef PDBMatrix(file):\n\t\tparser = PDBParser()\n\t\tstructure = parser.get_structure('protein', file)\n\n\t\t# Extract atomic coordinates\n\t\tcoordinates = []\n\t\tfor model in structure:\n\t\t\tfor chain in model:\n\t\t\t\t\tif chain.id == input.Chain():\n\t\t\t\t\t\t\tfor residue in chain:\n\t\t\t\t\t\t\t\t\tfor atom in residue:\n\t\t\t\t\t\t\t\t\t\t\tcoordinates.append(atom.coord)\n\n\t\t# Calculate pairwise Euclidean distances\n\t\tdistances = pdist(coordinates, metric=input.DistanceMethod().lower())\n\t\tdistance_matrix = squareform(distances)\n\n\t\treturn pd.DataFrame(distance_matrix)\n\n\n\tdef ChartMatrix(df):\n\t\tif \"Name\" in df:\n\t\t\tdistance_matrix = df.iloc[:, 1:].values\n\t\t\tpoint_names = df[\"Name\"]\n\n\t\telse:\n\t\t\tif 'x' in df.columns and 'y' in df.columns and 'z' in df.columns:\n\t\t\t\tcoordinates = df[['x', 'y', 'z']].values\n\t\t\t\tpoint_names = df[list(set(df.columns) - set(['x', 'y', 'z']))[0]].values\n\t\t\telse:\n\t\t\t\t# This will either handle a \n\t\t\t\tcoordinates = df.iloc[:, 1:].values\n\t\t\t\tpoint_names = None\n\n\t\tdistances = pdist(coordinates, metric=input.DistanceMethod().lower())\n\t\tdistance_matrix = squareform(distances)\n\n\t\treturn pd.DataFrame(distance_matrix, index=point_names, columns=point_names)\n\n\n\tdef GenerateHeatmap():\n\t\tdf = LoadData()\n\n\t\tfig, ax = plt.subplots()\n\n\t\tim = ax.imshow(df, cmap=input.ColorMap().lower(), interpolation=input.Interpolation().lower())\n\t\tplt.colorbar(im, label=\"Distance\")\n\n\t\treturn ax\n\n\t@output\n\t@render.table\n\tdef LoadedTable():\n\t\treturn LoadData()\n\n\t@output\n\t@render.plot\n\tdef Heatmap():\n\t\treturn GenerateHeatmap()\n\n\t@session.download(filename=\"table.csv\")\n\tdef DownloadTable():\n\t\tyield LoadData().to_string()\n\n\t@session.download(filename=\"heatmap.png\")\n\tdef DownloadHeatmap():\n\t\tax = GenerateHeatmap()\n\n\t\toutput = BytesIO()\n\t\tFigureCanvasAgg(ax.figure).print_png(output)\n\n\t\toutput.seek(0)\n\t\tyield output.read()\n\n\napp_ui = ui.page_fluid(\n\t# Place the Heatmapper Home on the top.\n\tui.panel_title(ui.HTML('<a href=\"https://kkernick.github.io\">Heatmapper</a>')),\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\t# If the user needs help with the formatting.\n\t\t\tui.HTML(\"<a href=https://kkernick.github.io/about/site/index.html>Data Format</a>\"),\n\n\t\t\t# Specify whether to use example files, or upload one.\n\t\t\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=\"Example\"),\n\n\t\t\t# Only display an input dialog if the user is one Upload\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.SourceFile === 'Upload'\",\n\t\t\t\tui.input_file(\"File\", \"Choose a File\", accept=[\".csv\", \".txt\", \"xlsx\", \".pdb\"], multiple=False),\n\t\t\t),\n\n\t\t\tui.br(),\n\n\t\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html\n\t\t\tui.input_select(id=\"DistanceMethod\", label=\"Distance Method\", choices=[\n\t\t\t\t\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Mahalanobis\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"], selected=\"Euclidean\"),\n\n\t\t\t# https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html\n\t\t\tui.input_select(id=\"Interpolation\", label=\"Interpolation\", choices=[\n\t\t\t\t\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"], selected=\"Nearest\"),\n\n\t\t\tui.input_select(id=\"ColorMap\", label=\"Color Map\", choices=[\"Viridis\", \"Plasma\", \"Inferno\", \"Magma\", \"Cividis\"], selected=\"Viridis\"),\n\n\t\t\tui.input_text(\"Chain\", \"PDB Chain\", \"A\"),\n\n\t\t\tui.br(),\n\n\t\t\t# Add the download buttons.\n\t\t\tui.layout_columns(\n\t\t\t\tui.download_button(\"DownloadTable\", \"Download Table\"),\n\t\t\t\tui.download_button(\"DownloadHeatmap\", \"Download Heatmap\")\n\t\t\t),\n\n\t\t\tid=\"SidebarPanel\",\n\t\t\twidth=350,\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tui.navset_tab(\n\n\t\t\t\t# The map\n\t\t\t\tui.nav_panel(\"Interactive\", ui.output_plot(\"Heatmap\", height=\"90vh\")),\n\n\t\t\t\t# The table\n\t\t\t\tui.nav_panel(\"Table\", ui.output_table(\"LoadedTable\"),),\n\t\t),\n\n\t\theight=\"100vh\"\n\t)\n)\t\n\napp = App(app_ui, server)", "type": "text"}, {"name": "requirements.txt", "content": "biopython", "type": "text"}]